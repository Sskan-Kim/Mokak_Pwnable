### Week1

[War Game]
[Obese Canary]

1. 취약점 파악: 스택의 구조해킹의 시작은 메모리가 어떻게 생겼는지 아는 것입니다.
   IDA를 통해 분석한 main 함수의 스택 구조는 다음과 같았습니다:
   buf (16바이트): 사용자가 입력을 주는 공간
   custom_canary (64바이트): 프로그램이 자체적으로 검증하는 가짜 카나리
   v7[8] (8바이트): 단순 패딩(Padding) 공간
   system_canary (8바이트): 운영체제가 삽입한 진짜 카나리
   RBP (8바이트): 이전 함수의 프레임 포인터
   Return Address (8바이트): 함수가 끝날 때 돌아갈 주소 (우리의 최종 목표물)

2. 첫 번째 벽: 커스텀 카나리 릭 (64바이트)이 프로그램은 사용자가 보낸 데이터와 메모리에 저장된 64바이트를 memcmp로 비교하여 다르면 "Injured"를 출력하고 종료합니다.
   원리: printf("%s", buf)는 NULL 바이트(\x00)를 만날 때까지 메모리를 읽습니다.
   공격: 우리가 buf 16바이트를 'a'로 꽉 채우면, 그 뒤에 바로 붙어 있는 커스텀 카나리와 buf 사이의 경계(NULL)가 사라집니다.
   결과: printf가 buf를 출력하다가 멈추지 않고 뒤에 있는 64바이트 카나리까지 줄줄이 출력하게 됩니다.
   
3. 두 번째 벽: 시스템 카나리 릭 (8바이트)시스템 카나리는 첫 번째 바이트가 항상 \x00입니다.
   printf가 이를 만나면 출력을 멈추기 때문에 일반적인 방법으로는 읽을 수 없습니다.
   원리: 릭을 할 때 첫 번째 바이트(\x00)를 강제로 다른 값으로 덮어써서 NULL을 없앱니다.
   공격: buf(16) + custom(64) + v7(8) + a(1)를 보냅니다.
   결과: NULL이 사라졌으므로 printf는 카나리의 나머지 7바이트를 출력합니다. 우리는 여기에 다시 \x00을 붙여서 완벽한 카나리 값을 복원합니다.
   
4. 세 번째 벽: PIE 우회 (주소 leak)PIE가 켜져 있으면 함수의 실제 주소가 실행할 때마다 바뀝니다.
   하지만 **"바이너리 내부의 상대적인 거리(Offset)"**는 변하지 않습니다.
   릭 지점 찾기: 스택 스캔을 통해 136번 오프셋 지점에 main+8의 실제 주소가 들어있음을 확인했습니다.
   계산: $실제 주소 - 오프셋(0x1289) = 바이너리 베이스 주소$.최종 목적지: 베이스 주소 + flag 함수 오프셋(0x158E)을 하면 서버의 실제 sub_158E 주소를 알아낼 수 있습니다.
   
5. 스택 정렬과 ret 가젯64비트 환경에서 printf 같은 함수가 포함된 곳으로 점프할 때는 스택이 16바이트 단위로 딱 맞춰져 있어야 합니다.
   문제: 그냥 점프하면 스택 정렬이 틀어져서 sub_158E 내부에서 죽어버립니다.
   해결: ret 가젯(주소 하나)을 페이로드 중간에 끼워 넣습니다. 이 가젯은 아무 일도 안 하고 8바이트를 소모하며 다음 주소로 넘겨주는 역할만 수행하여 스택 정렬을 맞춰줍니다.
   
6. 무한 루프의 이유: 확률적 성공코드가 왜 while True 루프 안에서 돌아갔을까요?
   NULL 바이트의 방해: 카나리 값은 랜덤하게 생성됩니다.
   만약 카나리 64바이트 중간에 우연히 \x00이 섞여 있으면, printf 릭이 거기서 끊겨버립니다.
   해결: 릭된 데이터가 64바이트보다 짧거나 주소 끝자리가 000이 아니면, "이번 판은 운이 없었다"고 판단하고 성공할 때까지 계속 다시 시도하는 것입니다.

   
